
# Monolithic architecture

- 하나의 DB와 하나의 프로젝트로 모든 서비스가 구성되어있는 일반적이고 단순한 구조

### 배포

- 단순히 하나의 application만 띄우면 되기 때문에 배포 파이프라인이 구성이 간단하다.
- 서비스 규모가 커질수록 빌드, 테스트, 배포하는 데 시간이 오래 걸린다.
- 조그마한 수정사항이 있어도 프로젝트 전체를 다시 빌드하고 배포해야 한다.

### 확장성

- 특정 서비스의 scale out이 어렵다.
    - 실제로 애플리케이션에서 트래픽은 골고루 집중되지 않는다. 그래서 특정 모듈만 성능을 높일 필요성이 생겼을 때 모놀리식의 경우 힘들다.

### 테스트 및 유지보수

- end-to-end 테스트 용이
    - 하나의 프로젝트에 전체 로직이 있기 때문에 통합 테스트 시 유리하다.
- 유지보수성
    - 규모가 작다면 유지보수는 간편하지만, 규모가 커질수록 코드량이 방대하고 복잡해지고 의존성 같은 것들도 늘어나면서 유지보수하기 힘들어진다.
- 일부의 오류가 발생해도 프로그램 전체에 영향을 미친다.
    - 약간의 사소한 오류로 서버가 다운돼도 모든 기능이 마비되는 셈이다.
- 결국 하나의 프로젝트에 있기 때문에 기능별로 알맞는 언어,프레임워크를 선택하기 까다롭다.
    - msa에 경우 서바마다 아예 다른 프레임워크와 기술을 사용할 수 있다.

---

# MSA

- 모놀리식 아키텍처를 Micro 단위로 쪼개서 독립적으로 구분하는 아키텍처.
- 단일 프로그램을 컴포넌트 단위로 나눠 **완전히 독립적으로 배포가 가능한 작은 서비스의 조합**으로 구축하는 방식

### 배포

- 각각의 독립된 서비스이기 때문에 서비스별로 개별 배포가 가능하다.
- 전체 서비스를 중단하지 않고도 일부만 배포가 가능해서 배포가 빠르다.

### 확장성

- 독립된 서비스이기 때문에 특정 서비스의 확장이 용이하다. ( scale out, scale up 둘 다 용이 )
- 각각 서비스는 새로운 언어나 프레임워크 등을 적용하기 편리하다.

### 테스트 및 유지보수

- 독립된 서비스 이기 때문에 전체 구조 파악이 모놀리식보다 용이하다. ( 서비스 별 파악 )
- 문제 발생 시 특정 서비스를 고립시켜 살펴볼 수 있어서 원인 탐색이 용이하다.

## 단점

- 독립된 서비스 간 호출 시 API를 사용하므로 통신 비용, 지연시간이 발생한다.
- 독립된 서비스의 조합이기 때문에 통합테스트가 어렵다.
- 데이터베이스가 분산되어 데이터 관리 및 트랜잭션 유지가 어렵다.
- 서비스들이 많아지면 로깅, 모니터링, 배포 등이 점점 복잡해진다.
- 모놀리식을 MSA로 전환 시 의존성 분리 작업이 어렵다.
- 각각의 서버 자원에 대한 비용이 든다.

---

# 어떤 architecture를 가져가야 하는가?

현재 우리 프로젝트는 모놀리식 구조로 되어있다.

거래서버 및 배치서버 등 별도의 독립된 서버에서 돌아가야 유리한 기능들이 존재한다.

메인 기능 중 하나인 거래서버 같은 경우 가장 많은 트래픽이 일어날 것이라 독립적인 서비스로 분리하면 scale out이 용이할 것이다.

기존 프로젝트 고도화를 하기로 했기 때문에 규모가 커져 코드량은 방대해지고 유지보수는 더 힘들어질 것이다.

이번에 테스트코드를 도입함으로써 배포시간은 더욱 늘어날 예정이다.

> 분리된 서비스의 구조를 가져가는 것이 용이해보임.
> 

## 우리팀 MSA도입 시 고려할 점..

- 싸피에서 주는 1개의 컴퓨터(ram16gb) 별도의 컴퓨팅 자원을 얼마나 가져가야 하는가
    - 비용
- 신기능 및 리팩토링, 기술도입 등의 시간을 합쳐서 할 수 있는 양인지?
    - 개발 시간 약 3 ~ 4주
    - MSA 공부 필요
    - 서버끼리 통신방식 (webflux) 및 API gate way, 별도의 컴퓨팅자원 세팅
- 팀원들의 의지
    - ,,

## 대안?

### Multi Module

- 모놀리식 아키텍처에서 각 서비스들을 모듈화시켜서 독립적으로 운영하는 방식.

<aside>
💡 모듈 module 이란?
java docs: 패키지의 한 단계 위 집합체, 즉 패키지의 집합.

</aside>

- 모듈간 통신은 주로 메모리 내에서 이뤄지므로 MSA와 달리 네트워크 오버헤드는 없음
- 의존성이 복잡해지면 테스트코드 작성과 통합테스트가 힘들어진다.
- 결국 모놀리식 방식이기 때문에 일부 수정이 전체 빌드, 테스트, 배포로 이어진다.
    - 특정 모듈을 분리하여 별도로 배포할 수도 있지만, 의존성 때문에 힘듦
- 결국 단일 애플리케이션이므로 기술적 확장성 제약이 있음
- 특정 모듈에 대한 scale out은 힘들다.

### 단일 컴퓨팅 자원에서 MSA와 멀티모듈 차이

- 멀티모듈은 결국 하나의 애플리케이션이므로 하나의 JVM에서 실행된다.
    - 한 모듈에서 발생한 문제가 JVM을 중단시킬 경우 전체 애플리케이션에 영향이 감.
- MSA는 별도의 애플리케이션이므로 각각의 JVM에서 실행된다.

<aside>
💡 멀티모듈을 사용하면서 MSA의 장점을 어느정도 가져갈 수 있을지는 코드의 모듈화정도일 듯하다.

</aside>

## 하나의 컴퓨팅 자원에서 사용한다면?

### **멀티모듈 아키텍처**

### 장점

- 빌드 테스트 배포 간단.
- 하나의 디비에서 데이터 일관성, 트랜잭션 관리 용이.
- JVM내에서 통신하므로 통신 오버헤드 x

### 단점

- 일부만 수정돼도 전체가 빌드, 테스트, 배포 해야되므로 규모가 커지면 시간비용 증가
- 특정 모듈만 확장 불가
- 일부가 문제가 발생하면 전체 서버 다운

### **마이크로서비스 아키텍처 (MSA)**

### 장점

- 빌드 테스트 배포를 각각 해줘야 하는 번거로움
- 독립적 확장 가능
- 일부 서비스의 다운이 다른 서비스에 영향을 주지 않음

### 단점

- 배포, 모니터링, 로깅 등 관리가 복잡,
- 같은 시스템 내에서도 네트워크 통신을 해야 함
- 데이터베이스를 어떻게 가져갈지 고민해야하고, 일관성을 유지하기 위한 설계 필요

> 멀티모듈과 MSA를 복합적으로 가져간다면,,,
단일 모듈 멀티 프로젝트
멀티 모듈 단일 프로젝트를 복잡적으로 가져가는 것도 생각해보자.
>


## 피드백
- SOA를 고려하라.
