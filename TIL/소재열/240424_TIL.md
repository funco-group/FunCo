
[RabbitMQ와 Kafka - 메시지 대기열 시스템 간의 차이점 - AWS](https://aws.amazon.com/ko/compare/the-difference-between-rabbitmq-and-kafka/)

**[RabbitMQ를 채팅에 사용하는 이유] - 경량, 신속, 유연성**

- 지연 시간이 낮기 때문에
    - 메모리 기반 메시징 지원
    - kafka는 디스크 기반 저장으로 디스크 I/O로 인해 지연 시간이 더 높음
- 메시지 브로커
    - 보다 능동적인 역할을 함
- 메시지 전달 보장
    - 메시지의 배달 확인(Delivery Acknowledgments) 기능을 통해 메시지가 안전하게 수신 확인할 수 있습니다.
- 유연한 라우팅
    - 다양한 타입의 Exchange를 통해 메시지를 적절한 큐로 효율적으로 라우팅할 수 있음, 채팅 애플리케이션에서 코인 별 그룹으로 메시지를 타겟팅해야함
- 경량 프로토콜
RabbitMQ는 AMQP(Advanced Message Queuing Protocol)을 사용하여 메시지를 처리하며, 이는 비교적 경량의 프로토콜입니다. 
이러한 경량 프로토콜은 네트워크 오버헤드를 줄여주어, 채팅과 같은 실시간 애플리케이션에서 낮은 지연성을 제공하는 데 유리합니다.
- 관리자를 위한 관리 인터페이스가 잘 구성되어 있어, 시스템의 상태를 쉽게 모니터링하고 조정할 수 있습니다. 채팅 애플리케이션 개발과 운영을 단순화 가능
- **높은 신뢰성과 클러스터링**
    - RabbitMQ는 높은 가용성과 클러스터링을 지원합니다. 이는 채팅 서비스의 연속성을 유지하고, 다운타임 없이 서비스를 계속 제공할 수 있게 해줍니다. 클러스터링을 통해 로드를 분산시키고, 노드 장애에도 메시지 서비스를 지속할 수 있습니다.

**[Kafka를 거래 처리에 사용하는 이유] - 대규모, 높은 신뢰성**

- 메시지를 분산 커밋 로그에 저장하므로 높은 확장성과 내결함성을 제공해 손실되면 안되는 정보인 **거래 데이터를 보장**하고 거래 요청이 많아졌을 경우 **높은 처리량**을 보장함.
- **Pull 기반 메시지 소비**: RabbitMQ와 ActiveMQ는 브로커가 컨슈머로 메시지를 Push 하는 방식인데 반해, 카프카는 컨슈머가 능동적으로 브로커로부터 메시지를 가져오는 Pull 방식을 취했다. 이로 인해 컨슈머는 처리 능력에 따라 메시지를 컨슘할 수 있기 때문에, 브로커로부터 압도당하지 않고 최적의 성능을 낼 수 있다.
거래 서버에서 거래 처리 속도가 차이나더라도 최적의 성능을 낼 수 있지 않을까 싶음
- **확장성**
    - Kafka는 수평적 확장성이 뛰어나며, 클러스터 내에 노드를 추가함으로써 처리 능력을 쉽게 증가시킬 수 있습니다. 큰 규모의 거래 시스템에서 거래 ID의 늘어나는 처리 요구를 쉽게 수용할 수 있습니다. MSA아키텍처로 개선한 것과 같은 이치
- **메시지 순서 유지**
    - Kafka는 토픽의 파티션 내에서 메시지의 순서를 유지합니다. 거래와 같이 순서가 중요한 작업에서는 이러한 순서 보장이 중요하며, 거래 처리의 정확성과 일관성을 유지하는 데 도움이 됩니다.
- 비동기 처리 작업
    - 스트림 처리 기능을 통해 복잡한 데이터 처리 및 분석 작업을 지원하기 때문에 비동기 팔로잉 거래 처리에 적합해보임

**[우리의 고민]**

- 로그 수집을 위해 Kafka or RabbitMQ?
- 현재 로그 수집 처리 서버에는 RabbitMQ가 설치되어 있는 상황
- 그러나 보편적으로 로그 수집을 위해서 대용량 처리가 필요하고, 이에 kafka가 적합한 후보로 제시됨

---

## RabbitMQ

RabbitMQ가 실시간 채팅 구현에 특히 적합한 이유는 몇 가지 주요 특성 때문입니다:

1. **낮은 지연 시간**: RabbitMQ는 메모리 기반 메시징을 지원하여 메시지를 매우 빠르게 전달할 수 있습니다. 이는 채팅 애플리케이션에서 중요한 요소로, 사용자 간의 대화가 거의 실시간으로 이루어져야 하기 때문입니다.
2. **메시지 순서의 보장**: RabbitMQ는 발송된 순서대로 메시지를 처리하고 전달할 수 있습니다. 채팅에서는 대화의 흐름을 올바르게 유지하는 것이 중요하며, 메시지가 순서대로 도착하는 것이 이를 보장합니다.
3. **가볍고 유연한 라우팅**: RabbitMQ는 다양한 라우팅 옵션과 패턴을 지원하여, 광범위한 유연성을 제공합니다. 특정 채널이나 사용자 그룹에 메시지를 동적으로 라우팅할 수 있으며, 이는 채팅 시스템에서 다양한 대화방이나 그룹 채팅 기능을 구현하는 데 유리합니다.
4. **확장성**: RabbitMQ는 클러스터링을 통해 시스템을 수평으로 확장할 수 있습니다. 채팅 애플리케이션의 사용자 수가 증가함에 따라, RabbitMQ 클러스터를 확장하여 더 많은 메시지와 더 높은 동시성을 처리할 수 있습니다.
5. **고가용성**: RabbitMQ는 미러 큐를 통해 메시지의 내구성과 고가용성을 보장할 수 있습니다. 이는 채팅 메시지가 중요한 경우에 특히 중요하며, 서버 하나가 실패하더라도 메시지 손실 없이 서비스가 계속 운영될 수 있습니다.
6. **개발자 친화성**: RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 기반으로 하며, 다양한 프로그래밍 언어와 잘 통합됩니다. 이로 인해 채팅 애플리케이션을 구축하려는 개발자가 RabbitMQ를 쉽게 도입하고 사용할 수 있습니다.

이러한 특성들 덕분에 RabbitMQ는 실시간성이 중요하고, 사용자 간의 상호 작용이 빈번한 채팅 애플리케이션 구축에 매우 적합한 선택이 됩니다.

## Kafka

Kafka가 갖는 주요 이점과 특정 상황에서 더 적합한 경우를 다음과 같이 요약할 수 있습니다:

### **Kafka의 이점**

1. **높은 처리량**: Kafka는 대량의 데이터를 빠르게 처리할 수 있도록 설계되었습니다. 분산 시스템 아키텍처 덕분에, 수천 개의 메시지를 초당 처리할 수 있으며, 이는 대규모 시스템에서 매우 유용합니다.
2. **내구성과 신뢰성**: Kafka는 모든 메시지를 디스크에 지속적으로 저장하여 높은 내구성을 제공합니다. 이는 시스템 장애가 발생하더라도 데이터 손실의 위험을 최소화합니다.
3. **확장성**: Kafka는 브로커(broker)를 추가함으로써 쉽게 확장할 수 있습니다. 이는 Kafka 클러스터가 성능 저하 없이 많은 양의 데이터와 높은 트래픽을 처리할 수 있음을 의미합니다.
4. **복제와 고가용성**: Kafka의 데이터는 클러스터의 여러 서버에 걸쳐 복제됩니다, 이는 시스템의 일부가 실패하더라도 전체 시스템이 계속 작동할 수 있도록 합니다.
5. **스트림 처리**: Kafka는 실시간 데이터 스트림 처리에 최적화되어 있습니다. Kafka Streams와 같은 도구를 사용하여 데이터를 실시간으로 분석하고 처리할 수 있습니다.

### **특히 적합한 상황**

1. **대규모 로그 처리 시스템**: 시스템이나 애플리케이션에서 발생하는 방대한 양의 로그 데이터를 수집, 저장 및 분석하는 데 Kafka가 자주 사용됩니다.
2. **실시간 스트림 처리**: 실시간으로 데이터를 분석하고 대응해야 하는 상황, 예를 들어 금융 거래 분석, 사기 탐지 시스템 등에 적합합니다.
3. **이벤트 소싱**: 애플리케이션 상태의 변화를 이벤트 스트림으로 모델링하는 이벤트 소싱 아키텍처에 Kafka는 중앙적인 역할을 할 수 있습니다.
4. **데이터 레이크**: 여러 소스에서 오는 데이터를 한 곳에 모으고, 이를 기반으로 데이터 사이언스 및 기계 학습 작업을 수행하는 데이터 레이크 구축에 유용합니다.

이러한 이점들 덕분에 Kafka는 대량의 데이터를 실시간으로 처리하고, 분석할 필요가 있는 복잡하고 대규모의 분산 환경에서 특히 유리합니다.

---

카프카는 대용량 데이터를 실시간으로 처리할 수 있도록 설계되었다. 따라서 높은 TPS를 가지며, 실시간 데이터 스트림

카프카의 메시지는 메모리가 아닌 디스크에 영구적으로 저장된다. 예로 Redis Pub/Sub과 같은 경우 메시지가 디스크에 저장되지 않으며, 장애 발생 시 메시지는 유실된다. 또 ActiveMQ, RabbitMQ 모두 디스크에 메시지를 영구 저장하는 옵션도 지원하지만, 기본적으로는 컨슘된 메시지는 소실된다. 반면 카프카는 기본적으로 모든 메시지를 디스크에 영구 저장한다.

분산 아키텍처: 후술하겠지만 카프카는 카프카 클러스터 내부에 여러대의 브로커 서버를 구성하여 높은 확장성(scalability)과 내결함성(fault tolerance)을 갖는다. 이는 RabbitMQ, ActiveMQ와 비교했을 때 **카프카만이 가지고 있는 차별점**이다.

**Pull 기반 메시지 소비**: RabbitMQ와 ActiveMQ는 브로커가 컨슈머로 메시지를 Push 하는 방식인데 반해, 카프카는 컨슈머가 능동적으로 브로커로부터 메시지를 가져오는 Pull 방식을 취했다. 이로 인해 컨슈머는 처리 능력에 따라 메시지를 컨슘할 수 있기 때문에, 브로커로부터 압도당하지 않고 최적의 성능을 낼 수 있다.

이벤트 스트리밍 플랫폼은 이벤트가 생성되면, 레코드 로그를 streamer에 기록하게 됩니다.
consumer가 topic을 가져간 후에도 이벤트 스트림에서 로그를 계속 유지하기 때문에 에러나 기타 문제가 생겼을 경우 이벤트를 재생할 수 있다는 강력한 장점이 있습니다.

이벤트 브로커는 Publisher가 생산한 이벤트(메세지)는 데이터베이스에 저장하듯 계속 저장하며, Consumer가 필요한 시점에 이벤트를 읽어가는 방식으로 동작하기 때문에, 장애가 일어나게 되면 그 이후의 이벤트들을 다시 처리할 수 있습니다.

### Kafka가 적절한 곳

Kafka는 복잡한 라우팅에 의존하지 않고 최대 처리량으로 이벤트 소싱, 스트리밍을 하는 데 적합합니다. 즉, 스트리밍 데이터를 저장, 읽기, 다시 읽기 및 분석하는 프레임워크가 필요한 경우 또는 정기적으로 감시하는 시스템이나 메세지를 영구적으로 저장하는데 적합합니다.

“실시간 처리”

### RabbitMQ가 적절한 곳

복잡한 라우팅이 필요하면서 신속한 요청-응답이 필요한 웹 서버에 적합합니다. 또한 부하가 높은 작업자 간에 부하를 공유하기 때문에 RabbitMQ는 백그라운드 작업이나 PDF 변환, 파일 검색 또는 이미지 확장과 같은 장기 실행 작업 처리에 적합합니다.

“장시간 실행되는 태스크, 안정적인 백그라운드 작업, 애플리케이션 간 내부 통신 및 통합”
